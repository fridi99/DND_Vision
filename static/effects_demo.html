<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ThemeFX ‚Äì Demo</title>
  <link rel="stylesheet" href="effects.css">
  <style>
    /* Canvas klick-durchl√§ssig halten */
    #reveal, #revealCanvas { pointer-events: none; }

    /* Toggle-Button oben rechts */
    .reveal-toggle {
      position: fixed;
      top: 12px; right: 12px;
      z-index: 10002;            /* √ºber Card, unter Modal */
      border: 1px solid rgba(255,255,255,0.12);
      background: #161a22;
      color: #e6e9ef;
      padding: .55rem .8rem;
      border-radius: 10px;
      font: 14px/1 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      cursor: pointer;
    }
    .reveal-toggle:hover { border-color: rgba(255,255,255,0.25); }
  </style>
</head>
<body>

<!-- Reveal-Layer: unten characters_background (in effects.css), oben das radierbare Bild -->
<div id="reveal"><canvas id="revealCanvas"></canvas></div>

<!-- ON/OFF oben rechts -->
<button id="toggleReveal" class="reveal-toggle">Reveal: ON</button>

<div class="app">
  <div class="card">
    <h2 style="margin:0 0 .4rem">ThemeFX ‚Äì Effects & API</h2>
    <p class="muted" style="margin:0 0 1rem">
      Click ‚ÄúChoose Effect‚Äù to open a small window. On <strong>hover</strong> you‚Äôll see short explanations.
      API: <code>ThemeFX.apply('blood'|'ice'|'fire')</code>, <code>ThemeFX.clear()</code>.
    </p>
    <div class="row">
      <button id="openFx" class="primary" aria-haspopup="dialog" aria-controls="fxModal">Choose Effect</button>
      <button id="clearFx">Clear Last</button>
      <button id="deleteNearestFx">Delete Nearest</button>
      <button id="escapeFx">Escape</button>
      <button id="nextMapFx">Next Map</button>
      <span class="muted">Current: <span id="currentFx" class="kbd">none</span></span>
    </div>
    <div class="spacer"></div>
    <p class="muted">Tip: Press <span class="kbd">Esc</span> to close the window.</p>
  </div>
</div>

<!-- Modal -->
<div id="fxOverlay" class="modal-overlay" tabindex="-1" aria-hidden="true"></div>
<div id="fxModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="fxTitle">
  <div class="modal-panel">
    <div class="modal-header">
      <div>
        <div id="fxTitle" class="modal-title">Select Effect</div>
        <div class="muted" style="font-size:12px">Pick a visual style for your theme.</div>
      </div>
      <button id="closeFx" aria-label="Close">‚úï</button>
    </div>

    <div class="grid" id="fxGrid" role="listbox" aria-label="Effects">
      <button class="fx-btn" data-fx="blood" role="option" aria-selected="false">
        <span class="fx-icon">ü©∏</span>
        <span class="fx-name">Blood</span>
        <span class="tooltip">Dark, gritty blood overlay</span>
      </button>
      <button class="fx-btn" data-fx="ice" role="option" aria-selected="false">
        <span class="fx-icon">‚ùÑÔ∏è</span>
        <span class="fx-name">Ice</span>
        <span class="tooltip">Cool icy tint & hatch</span>
      </button>
      <button class="fx-btn" data-fx="fire" role="option" aria-selected="false">
        <span class="fx-icon">üî•</span>
        <span class="fx-name">Fire</span>
        <span class="tooltip">Warm glow from below</span>
      </button>
    </div>

    <div class="spacer"></div>
    <div class="row" style="justify-content:flex-end">
      <button id="saveFx" class="primary">Apply</button>
    </div>
  </div>
</div>

<script>
  // ---------- Minimal API ----------
  (function(){
    const CLASS_MAP = { blood: 'effect-blood', ice: 'effect-ice', fire: 'effect-fire' };
    let current = null;

    function apply(name){
      clear();
      const cls = CLASS_MAP[name];
      if(!cls) return;
      document.body.classList.add(cls);
      current = name;
      dispatch('applied', { effect: name });
      updateBadge();
    }
    function clear(){
      Object.values(CLASS_MAP).forEach(c => document.body.classList.remove(c));
      if (current !== null) dispatch('cleared', { previous: current });
      current = null;
      updateBadge();
    }
    function get(){ return current; }
    function dispatch(type, detail){ window.dispatchEvent(new CustomEvent(`themefx:${type}`, { detail })); }
    function updateBadge(){
      const el = document.getElementById('currentFx');
      if (el) el.textContent = current ?? 'none';
      markActive(current);
    }
    window.ThemeFX = { apply, clear, get, effects: Object.keys(CLASS_MAP) };
  })();

  // ---------- UI / Modal ----------
  const modal = document.getElementById('fxModal');
  const overlay = document.getElementById('fxOverlay');
  const openBtn = document.getElementById('openFx');
  const closeBtn = document.getElementById('closeFx');
  const saveBtn = document.getElementById('saveFx');
  const clearBtn = document.getElementById('clearFx');
  const grid = document.getElementById('fxGrid');

  const FX_TO_TYPE = { blood:"s", ice:"c", fire:"r" };
  let pendingChoice = null;

  function openModal(){ overlay.classList.add('open'); modal.classList.add('open'); pendingChoice = ThemeFX.get(); markActive(pendingChoice); }
  function closeModal(){ overlay.classList.remove('open'); modal.classList.remove('open'); }

  openBtn.addEventListener('click', openModal);
  closeBtn.addEventListener('click', closeModal);
  overlay.addEventListener('click', closeModal);

  grid.addEventListener('click', (e)=>{
    const btn = e.target.closest('.fx-btn');
    if(!btn) return;
    pendingChoice = btn.dataset.fx;
    markActive(pendingChoice);
  });

  saveBtn.addEventListener('click', async () => {
    if (pendingChoice) {
      ThemeFX.apply(pendingChoice);
      const payload = { type: FX_TO_TYPE[pendingChoice] };
      if (payload.type) {
        await fetch("/effect", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
      }
    }
    closeModal();
  });

  clearBtn.addEventListener('click', async () => {
    ThemeFX.clear();
    await fetch("/deletelast", { method: "POST" });
    pendingChoice = null;
    markActive(null);
  });

  document.getElementById('deleteNearestFx').addEventListener('click', async () => {
    await fetch("/deletenearest", { method: "POST" });
  });
  document.getElementById('escapeFx').addEventListener('click', async () => {
    await fetch("/escape", { method: "POST" });
  });
  document.getElementById('nextMapFx').addEventListener('click', async () => {
    await fetch("/nextmap", { method: "POST", headers: { "Content-Type": "application/json" }, body: "{}" });
  });

  function markActive(name){
    grid.querySelectorAll('.fx-btn').forEach(b=>{
      const active = b.dataset.fx === name;
      b.classList.toggle('active', active);
      b.setAttribute('aria-selected', String(active));
    });
  }

  // ---------- Reveal-on-hover + Toggle ----------
  (function(){
    const canvas = document.getElementById('revealCanvas');
    const ctx = canvas.getContext('2d');

    const EFFECT_TO_IMG = {
      default: 'images/dragon-background.jpeg',
      blood:   'images/blood_effect.jpg',
      ice:     'images/ice_effect.jpg',
      fire:    'images/dragon-background.jpeg'
    };

    const toggleBtn = document.getElementById('toggleReveal');
    const topImg = new Image();

    let revealOn = true;   // Toggle-Status
    let topSrc = null;

    toggleBtn.addEventListener('click', () => {
      revealOn = !revealOn;
      toggleBtn.textContent = `Reveal: ${revealOn ? 'ON' : 'OFF'}`;
      // nichts neu zeichnen ‚Üí ‚Äûeingefrorener‚Äú Zustand bleibt sichtbar
    });

    function fitCanvas(){
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
      if (topImg.complete && topImg.naturalWidth) redrawTop();
    }

    function coverDraw(img){
      const cw = canvas.width, ch = canvas.height;
      const ir = img.width / img.height, cr = cw / ch;
      let w, h, x, y;
      if (cr > ir){ w = cw; h = cw / ir; x = 0; y = (ch - h)/2; }
      else        { h = ch; w = ch * ir; y = 0; x = (cw - w)/2; }
      ctx.drawImage(img, x, y, w, h);
    }

    function redrawTop(){
      ctx.globalCompositeOperation = 'source-over';
      ctx.clearRect(0,0,canvas.width,canvas.height);
      coverDraw(topImg);
      ctx.globalCompositeOperation = 'destination-out'; // Brush radiert wieder
    }

    function setTopByEffect(name){
      const src = EFFECT_TO_IMG[name || 'default'];
      if (src === topSrc){ redrawTop(); return; } // Effekt blieb gleich ‚Üí Maske zur√ºcksetzen
      topSrc = src;
      topImg.onload = redrawTop;
      topImg.src = src;
      if (topImg.complete && topImg.naturalWidth) redrawTop();
    }

    function isOverUi(target){
      return modal.classList.contains('open') ||
             modal.contains(target) ||
             overlay.contains(target) ||
             target.closest?.('.card') ||
             target.closest?.('.modal-panel');
    }

    // weicher Brush
    function eraseAt(x, y){
      if (!revealOn) return; // eingefroren
      const t = document.elementFromPoint(x, y);
      if (isOverUi(t)) return;

      const r = 90;
      const g = ctx.createRadialGradient(x, y, r*0.35, x, y, r);
      g.addColorStop(0, 'rgba(0,0,0,1)');
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fill();
    }

    document.addEventListener('mousemove', e => eraseAt(e.clientX, e.clientY), {passive:true});
    document.addEventListener('touchmove', e => {
      const t = e.touches[0]; if(!t) return;
      eraseAt(t.clientX, t.clientY);
    }, {passive:true});

    window.addEventListener('resize', fitCanvas);

    // Initial
    setTopByEffect(ThemeFX.get());
    fitCanvas();

    // Effektwechsel setzt Top-Bild neu und l√∂scht die Maske
    window.addEventListener('themefx:applied', e => setTopByEffect(e.detail.effect));
    window.addEventListener('themefx:cleared',  () => setTopByEffect('default'));
  })();
</script>
</body>
</html>