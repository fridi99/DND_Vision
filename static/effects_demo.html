<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>ThemeFX ‚Äì Demo</title>
    <link rel="stylesheet" href="effects.css">
</head>
<body>

<!-- ‚Üì Neues Reveal-Layer: unten liegt characters_background, oben wird ‚Äûweggerubbelt‚Äú -->
<div id="reveal">
    <canvas id="revealCanvas"></canvas>
</div>

<div class="app">
    <div class="card">
        <h2 style="margin:0 0 .4rem">ThemeFX ‚Äì Effects & API</h2>
        <p class="muted" style="margin:0 0 1rem">
            Click ‚ÄúChoose Effect‚Äù to open a small window. On <strong>hover</strong> you‚Äôll see short explanations.
            You can also control effects via API:
            <code>ThemeFX.apply('blood'|'ice'|'fire')</code>, <code>ThemeFX.clear()</code>.
        </p>
        <div class="row">
            <button id="openFx" class="primary" aria-haspopup="dialog" aria-controls="fxModal">Choose Effect</button>
            <button id="clearFx">Clear Last</button>
            <button id="deleteNearestFx">Delete Nearest</button>
            <button id="escapeFx">Escape</button>
            <button id="nextMapFx">Next Map</button>
            <span class="muted">Current: <span id="currentFx" class="kbd">none</span></span>
        </div>
        <div class="spacer"></div>
        <p class="muted">Tip: Press <span class="kbd">Esc</span> to close the window.</p>
    </div>
</div>

<!-- Modal -->
<div id="fxOverlay" class="modal-overlay" tabindex="-1" aria-hidden="true"></div>
<div id="fxModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="fxTitle">
    <div class="modal-panel">
        <div class="modal-header">
            <div>
                <div id="fxTitle" class="modal-title">Select Effect</div>
                <div class="muted" style="font-size:12px">Pick a visual style for your theme.</div>
            </div>
            <button id="closeFx" aria-label="Close">‚úï</button>
        </div>

        <div class="grid" id="fxGrid" role="listbox" aria-label="Effects">
            <button class="fx-btn" data-fx="blood" role="option" aria-selected="false">
                <span class="fx-icon">ü©∏</span>
                <span class="fx-name">Blood</span>
                <span class="tooltip">Dark, gritty blood overlay</span>
            </button>
            <button class="fx-btn" data-fx="ice" role="option" aria-selected="false">
                <span class="fx-icon">‚ùÑÔ∏è</span>
                <span class="fx-name">Ice</span>
                <span class="tooltip">Cool icy tint & hatch</span>
            </button>
            <button class="fx-btn" data-fx="fire" role="option" aria-selected="false">
                <span class="fx-icon">üî•</span>
                <span class="fx-name">Fire</span>
                <span class="tooltip">Warm glow from below</span>
            </button>
        </div>

        <div class="spacer"></div>
        <div class="row" style="justify-content:flex-end">
            <button id="saveFx" class="primary">Apply</button>
        </div>
    </div>
</div>

<script>
    // ---------- Minimal API ----------
    (function(){
      const CLASS_MAP = { blood: 'effect-blood', ice: 'effect-ice', fire: 'effect-fire' };
      let current = null;

      function apply(name){
        clear();
        const cls = CLASS_MAP[name];
        if(!cls) return;
        document.body.classList.add(cls);
        current = name;
        dispatch('applied', { effect: name });
        updateBadge();
      }
      function clear(){
        Object.values(CLASS_MAP).forEach(c => document.body.classList.remove(c));
        if (current !== null) dispatch('cleared', { previous: current });
        current = null;
        updateBadge();
      }
      function get(){ return current; }
      function dispatch(type, detail){ window.dispatchEvent(new CustomEvent(`themefx:${type}`, { detail })); }
      function updateBadge(){
        document.getElementById('currentFx').textContent = current ?? 'none';
        markActive(current);
      }
      window.ThemeFX = { apply, clear, get, effects: Object.keys(CLASS_MAP) };
    })();

    // ---------- UI / Modal ----------
    const modal = document.getElementById('fxModal');
    const overlay = document.getElementById('fxOverlay');
    const openBtn = document.getElementById('openFx');
    const closeBtn = document.getElementById('closeFx');
    const saveBtn = document.getElementById('saveFx');
    const clearBtn = document.getElementById('clearFx');
    const grid = document.getElementById('fxGrid');

    const FX_TO_TYPE = { blood:"s", ice:"c", fire:"r" };
    let pendingChoice = null;

    function openModal(){ overlay.classList.add('open'); modal.classList.add('open'); pendingChoice = ThemeFX.get(); markActive(pendingChoice); }
    function closeModal(){ overlay.classList.remove('open'); modal.classList.remove('open'); }

    openBtn.addEventListener('click', openModal);
    closeBtn.addEventListener('click', closeModal);
    overlay.addEventListener('click', closeModal);

    grid.addEventListener('click', (e)=>{
      const btn = e.target.closest('.fx-btn');
      if(!btn) return;
      pendingChoice = btn.dataset.fx;
      markActive(pendingChoice);
    });

    saveBtn.addEventListener('click', async () => {
      if (pendingChoice) {
        ThemeFX.apply(pendingChoice);
        const payload = { type: FX_TO_TYPE[pendingChoice] };
        if (payload.type) {
          await fetch("/effect", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
        }
      }
      closeModal();
    });

    clearBtn.addEventListener('click', async () => {
      ThemeFX.clear();
      await fetch("/deletelast", { method: "POST" });
      pendingChoice = null;
      markActive(null);
    });

    document.getElementById('deleteNearestFx').addEventListener('click', async () => {
      await fetch("/deletenearest", { method: "POST" });
    });
    document.getElementById('escapeFx').addEventListener('click', async () => {
      await fetch("/escape", { method: "POST" });
    });
    document.getElementById('nextMapFx').addEventListener('click', async () => {
      await fetch("/nextmap", { method: "POST", headers: { "Content-Type": "application/json" }, body: "{}" });
    });

    function markActive(name){
      grid.querySelectorAll('.fx-btn').forEach(b=>{
        const active = b.dataset.fx === name;
        b.classList.toggle('active', active);
        b.setAttribute('aria-selected', String(active));
      });
    }

    // ---------- Reveal-on-hover (freilegen) ----------
    (function(){
      const canvas = document.getElementById('revealCanvas');
      const ctx = canvas.getContext('2d');

      // Hinteres Bild liegt per CSS in #reveal
      const EFFECT_TO_IMG = {
        default: 'images/dragon-background.jpeg',
        blood:   'images/blood_effect.jpg',
        ice:     'images/ice_effect.jpg',
        fire:    'images/dragon-background.jpeg'
      };

      const topImg = new Image();
      let drawing = false; // nicht ben√∂tigt f√ºr Hover, aber verhindert Flood beim Resize

      function fitCanvas(){
        canvas.width  = window.innerWidth;
        canvas.height = window.innerHeight;
        if (topImg.complete) drawTop();
      }

      function drawTop(){
        const cw = canvas.width, ch = canvas.height;
        const ir = topImg.width / topImg.height, cr = cw / ch;
        let w, h, x, y;
        if (cr > ir){ w = cw; h = cw / ir; x = 0; y = (ch - h)/2; }
        else        { h = ch; w = ch * ir; y = 0; x = (cw - w)/2; }
        ctx.globalCompositeOperation = 'source-over';
        ctx.clearRect(0,0,cw,ch);
        ctx.drawImage(topImg, x, y, w, h);
        ctx.globalCompositeOperation = 'destination-out'; // Radierer
      }

      function setTopByEffect(name){
        const src = EFFECT_TO_IMG[name || 'default'];
        topImg.src = src;
      }

       //eraser for hover
      function eraseAt(x, y){
    const r = 80; // Radius (gr√∂√üer = weicher)
    const gradient = ctx.createRadialGradient(x, y, r * 0.3, x, y, r);
    gradient.addColorStop(0, 'rgba(0,0,0,1)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');

    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
  }

      // Hover freilegt: kein Klick n√∂tig
      window.addEventListener('mousemove', e => eraseAt(e.clientX, e.clientY), { passive:true });
      window.addEventListener('touchmove',  e => { const t=e.touches[0]; eraseAt(t.clientX,t.clientY); }, { passive:true });

      // Re-render bei Gr√∂√üe/ Bildwechsel
      window.addEventListener('resize', fitCanvas);
      topImg.onload = drawTop;

      // Initial
      setTopByEffect(ThemeFX.get());
      fitCanvas();

      // Auf ThemeFX-Ereignisse reagieren
      window.addEventListener('themefx:applied', e => { setTopByEffect(e.detail.effect); });
      window.addEventListener('themefx:cleared',  () => { setTopByEffect('default'); });
    })();
</script>
</body>
</html>